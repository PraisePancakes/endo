<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Endo: ndo Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Endo<span id="projectnumber">&#160;0.0.1-alpha</span>
   </div>
   <div id="projectbrief">C++ Modern Functional Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacendo.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ndo Namespace Reference<div class="ingroups"><a class="el" href="group__algebraic.html">Algebraic</a> &#124; <a class="el" href="group__algorithms.html">Algorithms</a> &#124; <a class="el" href="group__concepts.html">Concepts</a> &#124; <a class="el" href="group__functional.html">Functional</a> &#124; <a class="el" href="group__meta.html">Meta</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for algebraic types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:internal" id="r_internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacendo_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacendo_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y Combinator utility to enable anonymous recursion for lambdas. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:compositor" id="r_compositor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1compositor.html">compositor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for composing functions and threading computations.  <a href="structndo_1_1compositor.html#details">More...</a><br /></td></tr>
<tr class="memitem:either" id="r_either"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classndo_1_1either.html">either</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic type that holds a value (Right) or an error (Left).  <a href="classndo_1_1either.html#details">More...</a><br /></td></tr>
<tr class="memitem:flagnum" id="r_flagnum"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1flagnum.html">flagnum</a></td></tr>
<tr class="memitem:function_5Ftraits" id="r_function_5Ftraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits.html">function_traits</a></td></tr>
<tr class="memitem:function_5Ftraits_3C_20Ret_28_2A_29_28Args_2E_2E_2E_29_3E" id="r_function_5Ftraits_3C_20Ret_28_2A_29_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits_3_01_ret_07_5_08_07_args_8_8_8_08_4.html">function_traits&lt; Ret(*)(Args...)&gt;</a></td></tr>
<tr class="memitem:function_5Ftraits_3C_20Ret_28Args_2E_2E_2E_29_3E" id="r_function_5Ftraits_3C_20Ret_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits_3_01_ret_07_args_8_8_8_08_4.html">function_traits&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memitem:function_5Ftraits_3C_20Ret_28Class_3A_3A_2A_29_28Args_2E_2E_2E_29_20const_20_3E" id="r_function_5Ftraits_3C_20Ret_28Class_3A_3A_2A_29_28Args_2E_2E_2E_29_20const_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits_3_01_ret_07_class_1_1_5_08_07_args_8_8_8_08_01const_01_4.html">function_traits&lt; Ret(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="memitem:function_5Ftraits_3C_20Ret_28Class_3A_3A_2A_29_28Args_2E_2E_2E_29_3E" id="r_function_5Ftraits_3C_20Ret_28Class_3A_3A_2A_29_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits_3_01_ret_07_class_1_1_5_08_07_args_8_8_8_08_4.html">function_traits&lt; Ret(Class::*)(Args...)&gt;</a></td></tr>
<tr class="memitem:function_5Ftraits_3C_20std_3A_3Afunction_3C_20Ret_28Args_2E_2E_2E_29_3E_20_3E" id="r_function_5Ftraits_3C_20std_3A_3Afunction_3C_20Ret_28Args_2E_2E_2E_29_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits_3_01std_1_1function_3_01_ret_07_args_8_8_8_08_4_01_4.html">function_traits&lt; std::function&lt; Ret(Args...)&gt; &gt;</a></td></tr>
<tr class="memitem:function_5Ftraits_5Fmeta" id="r_function_5Ftraits_5Fmeta"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1function__traits__meta.html">function_traits_meta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts type traits from callable types.  <a href="structndo_1_1function__traits__meta.html#details">More...</a><br /></td></tr>
<tr class="memitem:hash_5Ft" id="r_hash_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1hash__t.html">hash_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a unique type-based identifier.  <a href="structndo_1_1hash__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fbasic_5Fstring" id="r_is_5Fbasic_5Fstring"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__basic__string.html">is_basic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a type is a specialization of <span class="tt">std::basic_string</span>.  <a href="structndo_1_1is__basic__string.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fbasic_5Fstring_3C_20std_3A_3Abasic_5Fstring_3C_20CharT_2C_20Traits_2C_20Allocator_20_3E_20_3E" id="r_is_5Fbasic_5Fstring_3C_20std_3A_3Abasic_5Fstring_3C_20CharT_2C_20Traits_2C_20Allocator_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__basic__string_3_01std_1_1basic__string_3_01_char_t_00_01_traits_00_01_allocator_01_4_01_4.html">is_basic_string&lt; std::basic_string&lt; CharT, Traits, Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <span class="tt">std::basic_string</span> types sets to <span class="tt">true</span>.  <a href="structndo_1_1is__basic__string_3_01std_1_1basic__string_3_01_char_t_00_01_traits_00_01_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fmaybe_5Ftrait" id="r_is_5Fmaybe_5Ftrait"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__maybe__trait.html">is_maybe_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a type is an instantiation of <span class="tt">maybe</span>.  <a href="structndo_1_1is__maybe__trait.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fmaybe_5Ftrait_3C_20maybe_3C_20T_20_3E_20_3E" id="r_is_5Fmaybe_5Ftrait_3C_20maybe_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__maybe__trait_3_01maybe_3_01_t_01_4_01_4.html">is_maybe_trait&lt; maybe&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <span class="tt">maybe&lt;T&gt;</span> sets to <span class="tt">true</span>.  <a href="structndo_1_1is__maybe__trait_3_01maybe_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fnoexcept" id="r_is_5Fnoexcept"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__noexcept.html">is_noexcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to detect if a function type is declared <span class="tt">noexcept</span>.  <a href="structndo_1_1is__noexcept.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fnoexcept_3C_20F_28Args_2E_2E_2E_29_20noexcept_20_3E" id="r_is_5Fnoexcept_3C_20F_28Args_2E_2E_2E_29_20noexcept_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__noexcept_3_01_f_07_args_8_8_8_08_01noexcept_01_4.html">is_noexcept&lt; F(Args...) noexcept &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <span class="tt">noexcept</span> function types sets to <span class="tt">true</span>.  <a href="structndo_1_1is__noexcept_3_01_f_07_args_8_8_8_08_01noexcept_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fnothing_5Ftrait" id="r_is_5Fnothing_5Ftrait"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__nothing__trait.html">is_nothing_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect if a type is <span class="tt">maybe&lt;<a class="el" href="structndo_1_1ndo__null__t.html" title="Tag type used to represent &quot;no value&quot;.">ndo_null_t</a>&gt;</span>.  <a href="structndo_1_1is__nothing__trait.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fnothing_5Ftrait_3C_20maybe_3C_20ndo_5Fnull_5Ft_20_3E_20_3E" id="r_is_5Fnothing_5Ftrait_3C_20maybe_3C_20ndo_5Fnull_5Ft_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1is__nothing__trait_3_01maybe_3_01ndo__null__t_01_4_01_4.html">is_nothing_trait&lt; maybe&lt; ndo_null_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <span class="tt">maybe&lt;<a class="el" href="structndo_1_1ndo__null__t.html" title="Tag type used to represent &quot;no value&quot;.">ndo_null_t</a>&gt;</span> sets to <span class="tt">true</span>.  <a href="structndo_1_1is__nothing__trait_3_01maybe_3_01ndo__null__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:maybe" id="r_maybe"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classndo_1_1maybe.html">maybe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that may hold a value or nothing.  <a href="classndo_1_1maybe.html#details">More...</a><br /></td></tr>
<tr class="memitem:maybe_3C_20ndo_5Fnull_5Ft_20_3E" id="r_maybe_3C_20ndo_5Fnull_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classndo_1_1maybe_3_01ndo__null__t_01_4.html">maybe&lt; ndo_null_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <span class="tt">maybe</span> for <span class="tt"><a class="el" href="structndo_1_1ndo__null__t.html" title="Tag type used to represent &quot;no value&quot;.">ndo_null_t</a></span>.  <a href="classndo_1_1maybe_3_01ndo__null__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:name_5Fof" id="r_name_5Fof"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of.html">name_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time type name mapping.  <a href="structndo_1_1name__of.html#details">More...</a><br /></td></tr>
<tr class="memitem:name_5Fof_3C_20char_20_3E" id="r_name_5Fof_3C_20char_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01char_01_4.html">name_of&lt; char &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20float_20_3E" id="r_name_5Fof_3C_20float_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01float_01_4.html">name_of&lt; float &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20int_20_3E" id="r_name_5Fof_3C_20int_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01int_01_4.html">name_of&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializations for fundamental and standard types:  <a href="structndo_1_1name__of_3_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:name_5Fof_3C_20long_20_3E" id="r_name_5Fof_3C_20long_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01long_01_4.html">name_of&lt; long &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20std_3A_3Auint16_5Ft_20_3E" id="r_name_5Fof_3C_20std_3A_3Auint16_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01std_1_1uint16__t_01_4.html">name_of&lt; std::uint16_t &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20std_3A_3Auint32_5Ft_20_3E" id="r_name_5Fof_3C_20std_3A_3Auint32_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01std_1_1uint32__t_01_4.html">name_of&lt; std::uint32_t &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20std_3A_3Auint64_5Ft_20_3E" id="r_name_5Fof_3C_20std_3A_3Auint64_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01std_1_1uint64__t_01_4.html">name_of&lt; std::uint64_t &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20std_3A_3Auint8_5Ft_20_3E" id="r_name_5Fof_3C_20std_3A_3Auint8_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01std_1_1uint8__t_01_4.html">name_of&lt; std::uint8_t &gt;</a></td></tr>
<tr class="memitem:name_5Fof_3C_20void_20_3E" id="r_name_5Fof_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1name__of_3_01void_01_4.html">name_of&lt; void &gt;</a></td></tr>
<tr class="memitem:ndo_5Fnull_5Ft" id="r_ndo_5Fnull_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1ndo__null__t.html">ndo_null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to represent "no value".  <a href="structndo_1_1ndo__null__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:type_5Fdescriptor" id="r_type_5Fdescriptor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1type__descriptor.html">type_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a human-readable string representation of a type <span class="tt">T</span>.  <a href="structndo_1_1type__descriptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:type_5Fset" id="r_type_5Fset"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classndo_1_1type__set.html">type_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time set of types providing metaprogramming utilities.  <a href="classndo_1_1type__set.html#details">More...</a><br /></td></tr>
<tr class="memitem:type_5Fset_3C_20T_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_type_5Fset_3C_20T_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1type__set_3_01_t_3_01_ts_8_8_8_01_4_01_4.html">type_set&lt; T&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:visitor" id="r_visitor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structndo_1_1visitor.html">visitor</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:Addable" id="r_Addable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_addable.html">Addable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to support addition operations. <br /></td></tr>
<tr class="memitem:AllocatorAware" id="r_AllocatorAware"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_allocator_aware.html">AllocatorAware</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to provide an allocator accessor. <br /></td></tr>
<tr class="memitem:AllocatorEraseable" id="r_AllocatorEraseable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_allocator_eraseable.html">AllocatorEraseable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires an allocator to be able to destroy an object of type <span class="tt">E</span>. <br /></td></tr>
<tr class="memitem:Arithmetical" id="r_Arithmetical"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_arithmetical.html">Arithmetical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept representing types that support basic arithmetic operations. <br /></td></tr>
<tr class="memitem:Comparable" id="r_Comparable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_comparable.html">Comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to support all standard comparison operators. <br /></td></tr>
<tr class="memitem:DefaultErasable" id="r_DefaultErasable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_default_erasable.html">DefaultErasable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a pointer to an object of type <span class="tt">E</span> to be destroyable via <span class="tt">std::destroy_at</span>. <br /></td></tr>
<tr class="memitem:Divisible" id="r_Divisible"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_divisible.html">Divisible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to support division operations. <br /></td></tr>
<tr class="memitem:Eraseable" id="r_Eraseable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_eraseable.html">Eraseable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if type <span class="tt">T</span> can erase elements of type <span class="tt">E</span>. <br /></td></tr>
<tr class="memitem:Hashable" id="r_Hashable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_hashable.html">Hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to be hashable by <span class="tt">std::hash</span>. <br /></td></tr>
<tr class="memitem:is_5Fmaybe" id="r_is_5Fmaybe"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1is__maybe.html">is_maybe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a type is a <span class="tt">maybe</span> instantiation. <br /></td></tr>
<tr class="memitem:ndo_5Fcallable" id="r_ndo_5Fcallable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1ndo__callable.html">ndo_callable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a type is callable and compatible with <span class="tt">function_traits</span>. <br /></td></tr>
<tr class="memitem:is_5Fnothing" id="r_is_5Fnothing"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1is__nothing.html">is_nothing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a type is <span class="tt">maybe&lt;ndo_null_t&gt;</span>. <br /></td></tr>
<tr class="memitem:is_5Fspecialization_5Fof" id="r_is_5Fspecialization_5Fof"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1is__specialization__of.html">is_specialization_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a type <span class="tt">T</span> is a specialization of a class template <span class="tt">Template</span>. <br /></td></tr>
<tr class="memitem:Container" id="r_Container"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_container.html">Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to fulfill typical container requirements. <br /></td></tr>
<tr class="memitem:Multipliable" id="r_Multipliable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_multipliable.html">Multipliable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to support multiplication operations. <br /></td></tr>
<tr class="memitem:satisfies_5Fit" id="r_satisfies_5Fit"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1satisfies__it.html">satisfies_it</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks if a template lambda or functor <span class="tt">F</span> can be invoked with template parameters <span class="tt">Ts...</span>. <br /></td></tr>
<tr class="memitem:Streamable" id="r_Streamable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_streamable.html">Streamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to support streaming to <span class="tt">std::ostream</span>. <br /></td></tr>
<tr class="memitem:Subtractable" id="r_Subtractable"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptndo_1_1_subtractable.html">Subtractable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that requires a type to support subtraction operations. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac5227294baa18e705d021c99e88f67f0" id="r_ac5227294baa18e705d021c99e88f67f0"><td class="memTemplParams" colspan="2"><a id="ac5227294baa18e705d021c99e88f67f0" name="ac5227294baa18e705d021c99e88f67f0"></a>
template&lt;std::size_t C&gt; </td></tr>
<tr class="memitem:ac5227294baa18e705d021c99e88f67f0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> = std::integral_constant&lt;std::size_t, C&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65182d6a37c20442b888cb6428be5b6b" id="r_a65182d6a37c20442b888cb6428be5b6b"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2&gt; <br />
requires (std::tuple_size_v&lt;T1&gt; == std::tuple_size_v&lt;T2&gt;)</td></tr>
<tr class="memitem:a65182d6a37c20442b888cb6428be5b6b template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65182d6a37c20442b888cb6428be5b6b">flat_zip</a> (const T1 &amp;t1, const T2 &amp;t2) noexcept</td></tr>
<tr class="memdesc:a65182d6a37c20442b888cb6428be5b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips two tuples of the same size into a flat tuple of values.  <br /></td></tr>
<tr class="memitem:abacc9b6aaa2af1ddfb77b8fd35877cf5" id="r_abacc9b6aaa2af1ddfb77b8fd35877cf5"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:abacc9b6aaa2af1ddfb77b8fd35877cf5 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abacc9b6aaa2af1ddfb77b8fd35877cf5">flatten</a> (const std::vector&lt; T &gt; &amp;in, std::vector&lt; U &gt; &amp;out) noexcept</td></tr>
<tr class="memdesc:abacc9b6aaa2af1ddfb77b8fd35877cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a single-level <span class="tt">std::vector&lt;T&gt;</span> into <span class="tt">std::vector&lt;U&gt;</span>.  <br /></td></tr>
<tr class="memitem:a3b6aa0a050176c495293e7b2eb9b4729" id="r_a3b6aa0a050176c495293e7b2eb9b4729"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:a3b6aa0a050176c495293e7b2eb9b4729 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b6aa0a050176c495293e7b2eb9b4729">flatten</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;vec, std::vector&lt; U &gt; &amp;out) noexcept</td></tr>
<tr class="memdesc:a3b6aa0a050176c495293e7b2eb9b4729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively flattens a nested <span class="tt">std::vector&lt;std::vector&lt;T&gt;&gt;</span> into <span class="tt">std::vector&lt;U&gt;</span>.  <br /></td></tr>
<tr class="memitem:a9e2b8e4e1c08763308012ae0ca7f72c3" id="r_a9e2b8e4e1c08763308012ae0ca7f72c3"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Cond&gt; <br />
requires (std::is_invocable_r_v&lt;bool, Cond, typename Container::value_type&gt;)</td></tr>
<tr class="memitem:a9e2b8e4e1c08763308012ae0ca7f72c3 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e2b8e4e1c08763308012ae0ca7f72c3">keep_if</a> (const Container &amp;cont, Cond &amp;&amp;c) noexcept(std::is_nothrow_invocable_v&lt; Cond, typename Container::value_type &gt;)</td></tr>
<tr class="memdesc:a9e2b8e4e1c08763308012ae0ca7f72c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters elements of a container based on a predicate.  <br /></td></tr>
<tr class="memitem:a03d7c5bc315b6dd3c4466d37ea95e643" id="r_a03d7c5bc315b6dd3c4466d37ea95e643"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename F&gt; <br />
requires (std::is_invocable_v&lt;F, typename Container::value_type&gt;)</td></tr>
<tr class="memitem:a03d7c5bc315b6dd3c4466d37ea95e643 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03d7c5bc315b6dd3c4466d37ea95e643">map_from</a> (const Container &amp;cont, F &amp;&amp;f) noexcept(std::is_nothrow_invocable_v&lt; F, typename Container::value_type &gt;)</td></tr>
<tr class="memdesc:a03d7c5bc315b6dd3c4466d37ea95e643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation to each element of a container and returns a container of the same type.  <br /></td></tr>
<tr class="memitem:a439e187de8bc525072d20b4461e8b599" id="r_a439e187de8bc525072d20b4461e8b599"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Cond&gt; <br />
requires (std::is_invocable_r_v&lt;bool, Cond, typename Container::value_type&gt;)</td></tr>
<tr class="memitem:a439e187de8bc525072d20b4461e8b599 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a439e187de8bc525072d20b4461e8b599">remove_if</a> (const Container &amp;cont, Cond &amp;&amp;c) noexcept(std::is_nothrow_invocable_v&lt; Cond, typename Container::value_type &gt;)</td></tr>
<tr class="memdesc:a439e187de8bc525072d20b4461e8b599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new container with elements that do <b>not</b> satisfy the given predicate.  <br /></td></tr>
<tr class="memitem:a0d05ac36588cc43e0659726e8e955f34" id="r_a0d05ac36588cc43e0659726e8e955f34"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a0d05ac36588cc43e0659726e8e955f34 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d05ac36588cc43e0659726e8e955f34">reverse</a> (const Container &amp;cont) noexcept</td></tr>
<tr class="memdesc:a0d05ac36588cc43e0659726e8e955f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new container with the elements of the input container in reverse order.  <br /></td></tr>
<tr class="memitem:a307cad0ca115c951c3c7bc46f65b39e2" id="r_a307cad0ca115c951c3c7bc46f65b39e2"><td class="memTemplParams" colspan="2">template&lt;std::integral N = int&gt; </td></tr>
<tr class="memitem:a307cad0ca115c951c3c7bc46f65b39e2 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307cad0ca115c951c3c7bc46f65b39e2">spread</a> (N a, N b) noexcept</td></tr>
<tr class="memdesc:a307cad0ca115c951c3c7bc46f65b39e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector containing an inclusive range of integral values.  <br /></td></tr>
<tr class="memitem:a3dd07bd4accf005c34f55ad9bafc2101" id="r_a3dd07bd4accf005c34f55ad9bafc2101"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a3dd07bd4accf005c34f55ad9bafc2101 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dd07bd4accf005c34f55ad9bafc2101">to_indexed_map</a> (const Container &amp;cont) noexcept</td></tr>
<tr class="memdesc:a3dd07bd4accf005c34f55ad9bafc2101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <span class="tt">std::unordered_map</span> mapping indices to elements from a container.  <br /></td></tr>
<tr class="memitem:a6ea51ea050153fbe7f63e41df230aba1" id="r_a6ea51ea050153fbe7f63e41df230aba1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6ea51ea050153fbe7f63e41df230aba1 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea51ea050153fbe7f63e41df230aba1">unzip</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a6ea51ea050153fbe7f63e41df230aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a tuple of pairs into a concatenated tuple of first and second elements.  <br /></td></tr>
<tr class="memitem:acc8dfdc59a3ebf663e395c64c577a4ae" id="r_acc8dfdc59a3ebf663e395c64c577a4ae"><td class="memTemplParams" colspan="2">template&lt;typename T1, typename T2&gt; <br />
requires (std::tuple_size_v&lt;T1&gt; == std::tuple_size_v&lt;T2&gt;)</td></tr>
<tr class="memitem:acc8dfdc59a3ebf663e395c64c577a4ae template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8dfdc59a3ebf663e395c64c577a4ae">zip</a> (const T1 &amp;t1, const T2 &amp;t2) noexcept</td></tr>
<tr class="memdesc:acc8dfdc59a3ebf663e395c64c577a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two tuples of the same size into a tuple of pairs.  <br /></td></tr>
<tr class="memitem:a78bc4953ef2854ef5a86edde6c8b0167" id="r_a78bc4953ef2854ef5a86edde6c8b0167"><td class="memTemplParams" colspan="2"><a id="a78bc4953ef2854ef5a86edde6c8b0167" name="a78bc4953ef2854ef5a86edde6c8b0167"></a>
template&lt;typename F&gt; </td></tr>
<tr class="memitem:a78bc4953ef2854ef5a86edde6c8b0167 template"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><b>make_y_combinator</b> (F &amp;&amp;f)</td></tr>
<tr class="memitem:ae159491e2b5c2833e2401e2e3550bb9a" id="r_ae159491e2b5c2833e2401e2e3550bb9a"><td class="memTemplParams" colspan="2"><a id="ae159491e2b5c2833e2401e2e3550bb9a" name="ae159491e2b5c2833e2401e2e3550bb9a"></a>
template&lt;typename F&gt; </td></tr>
<tr class="memitem:ae159491e2b5c2833e2401e2e3550bb9a template"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><b>curry</b> (F &amp;&amp;f) noexcept</td></tr>
<tr class="memitem:a610b41c74cf1fb65f05a95136058569e" id="r_a610b41c74cf1fb65f05a95136058569e"><td class="memTemplParams" colspan="2"><a id="a610b41c74cf1fb65f05a95136058569e" name="a610b41c74cf1fb65f05a95136058569e"></a>
template&lt;typename F&gt; </td></tr>
<tr class="memitem:a610b41c74cf1fb65f05a95136058569e template"><td class="memItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><b>uncurry</b> (F &amp;&amp;f) noexcept</td></tr>
<tr class="memitem:a97cbb65bb009f1c7a991fdf9fd272372" id="r_a97cbb65bb009f1c7a991fdf9fd272372"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename F, typename... Args&gt; </td></tr>
<tr class="memitem:a97cbb65bb009f1c7a991fdf9fd272372 template"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97cbb65bb009f1c7a991fdf9fd272372">static_for</a> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a97cbb65bb009f1c7a991fdf9fd272372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a callable <span class="tt">f</span> with compile-time indices from 0 to N-1.  <br /></td></tr>
<tr class="memitem:ab5240d9ad007f29e258bda4396b2c966" id="r_ab5240d9ad007f29e258bda4396b2c966"><td class="memTemplParams" colspan="2"><a id="ab5240d9ad007f29e258bda4396b2c966" name="ab5240d9ad007f29e258bda4396b2c966"></a>
template&lt;typename E&gt; <br />
requires std::is_enum_v&lt;E&gt;</td></tr>
<tr class="memitem:ab5240d9ad007f29e258bda4396b2c966 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structndo_1_1flagnum.html">flagnum</a>&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (E lhs, E rhs)</td></tr>
<tr class="memitem:a0c89bc2489da5c0050eb7e175e100590" id="r_a0c89bc2489da5c0050eb7e175e100590"><td class="memTemplParams" colspan="2"><a id="a0c89bc2489da5c0050eb7e175e100590" name="a0c89bc2489da5c0050eb7e175e100590"></a>
template&lt;typename E&gt; <br />
requires std::is_enum_v&lt;E&gt;</td></tr>
<tr class="memitem:a0c89bc2489da5c0050eb7e175e100590 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structndo_1_1flagnum.html">flagnum</a>&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (E lhs, E rhs)</td></tr>
<tr class="memitem:a3a852bf990b77af1804a692ac3e3f48c" id="r_a3a852bf990b77af1804a692ac3e3f48c"><td class="memTemplParams" colspan="2"><a id="a3a852bf990b77af1804a692ac3e3f48c" name="a3a852bf990b77af1804a692ac3e3f48c"></a>
template&lt;typename E&gt; <br />
requires std::is_enum_v&lt;E&gt;</td></tr>
<tr class="memitem:a3a852bf990b77af1804a692ac3e3f48c template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structndo_1_1flagnum.html">flagnum</a>&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator~</b> (E val)</td></tr>
<tr class="memitem:a853a364d3717e1c9632fd1073d36114c" id="r_a853a364d3717e1c9632fd1073d36114c"><td class="memTemplParams" colspan="2"><a id="a853a364d3717e1c9632fd1073d36114c" name="a853a364d3717e1c9632fd1073d36114c"></a>
template&lt;typename... Fs&gt; </td></tr>
<tr class="memitem:a853a364d3717e1c9632fd1073d36114c template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>visitor</b> (Fs...) -&gt; visitor&lt; Fs... &gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3d8877e34a484a7b879102872d175b01" id="r_a3d8877e34a484a7b879102872d175b01"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structndo_1_1ndo__null__t.html">ndo_null_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d8877e34a484a7b879102872d175b01">ndo_nothing</a> {}</td></tr>
<tr class="memdesc:a3d8877e34a484a7b879102872d175b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton instance of <span class="tt"><a class="el" href="structndo_1_1ndo__null__t.html" title="Tag type used to represent &quot;no value&quot;.">ndo_null_t</a></span>.  <br /></td></tr>
<tr class="memitem:a5523fe9ec1bccdf22e37455c3e60fa3a" id="r_a5523fe9ec1bccdf22e37455c3e60fa3a"><td class="memTemplParams" colspan="2"><a id="a5523fe9ec1bccdf22e37455c3e60fa3a" name="a5523fe9ec1bccdf22e37455c3e60fa3a"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a5523fe9ec1bccdf22e37455c3e60fa3a template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_basic_string_v</b> = <a class="el" href="structndo_1_1is__basic__string.html">is_basic_string</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5523fe9ec1bccdf22e37455c3e60fa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template for <span class="tt"><a class="el" href="structndo_1_1is__basic__string.html" title="Type trait to detect if a type is a specialization of std::basic_string.">is_basic_string</a></span>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for algebraic types. </p>
<p>Namespace for metaprogramming utilities.</p>
<p>Namespace for functional utilities.</p>
<p>Namespace for metaprogramming traits and concepts.</p>
<p>Namespace for generic tuple and container utilities.</p>
<p>Namespace for generic algorithms and data generation utilities.</p>
<p>Namespace for generic algorithms and transformations.</p>
<p>Namespace for generic algorithms and predicates.</p>
<p>Namespace for generic algorithms and data transformations.</p>
<p>Namespace for generic algorithms and utilities.</p>
<p>Namespace for generic algorithms. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a65182d6a37c20442b888cb6428be5b6b" name="a65182d6a37c20442b888cb6428be5b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65182d6a37c20442b888cb6428be5b6b">&#9670;&#160;</a></span>flat_zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; <br />
requires (std::tuple_size_v&lt;T1&gt; == std::tuple_size_v&lt;T2&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::flat_zip </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zips two tuples of the same size into a flat tuple of values. </p>
<p>Given two tuples <span class="tt">t1</span> and <span class="tt">t2</span> of the same size, returns a new tuple containing <span class="tt">value</span>s of elements at corresponding indices.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"><span class="keyword">auto</span> t2 = std::make_tuple(2.0, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="#a65182d6a37c20442b888cb6428be5b6b">flat_zip</a>(t1, t2); <span class="comment">// result is std::tuple&lt;int, double, char, const char*&gt;</span></div>
<div class="ttc" id="anamespacendo_html_a65182d6a37c20442b888cb6428be5b6b"><div class="ttname"><a href="#a65182d6a37c20442b888cb6428be5b6b">ndo::flat_zip</a></div><div class="ttdeci">constexpr auto flat_zip(const T1 &amp;t1, const T2 &amp;t2) noexcept</div><div class="ttdoc">Zips two tuples of the same size into a flat tuple of values.</div><div class="ttdef"><b>Definition</b> flat_zip.hpp:36</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first tuple. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the second tuple.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>The first input tuple. </td></tr>
    <tr><td class="paramname">t2</td><td>The second input tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple of <span class="tt">value</span>s created from <span class="tt">t1[i]</span> and <span class="tt">t2[i]</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires <span class="tt">std::tuple_size_v&lt;T1&gt; == std::tuple_size_v&lt;T2&gt;</span>. </dd></dl>

</div>
</div>
<a id="a3b6aa0a050176c495293e7b2eb9b4729" name="a3b6aa0a050176c495293e7b2eb9b4729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6aa0a050176c495293e7b2eb9b4729">&#9670;&#160;</a></span>flatten() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ndo::flatten </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively flattens a nested <span class="tt">std::vector&lt;std::vector&lt;T&gt;&gt;</span> into <span class="tt">std::vector&lt;U&gt;</span>. </p>
<p>Traverses the 2D vector and inserts all inner elements into <span class="tt">out</span>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type inside inner vectors. </td></tr>
    <tr><td class="paramname">U</td><td>The output vector element type. Must be assignable from <span class="tt">T</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The input 2D vector. </td></tr>
    <tr><td class="paramname">out</td><td>The output vector to populate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abacc9b6aaa2af1ddfb77b8fd35877cf5" name="abacc9b6aaa2af1ddfb77b8fd35877cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacc9b6aaa2af1ddfb77b8fd35877cf5">&#9670;&#160;</a></span>flatten() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ndo::flatten </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flattens a single-level <span class="tt">std::vector&lt;T&gt;</span> into <span class="tt">std::vector&lt;U&gt;</span>. </p>
<p>Copies all elements from <span class="tt">in</span> into the end of <span class="tt">out</span>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The input vector element type. </td></tr>
    <tr><td class="paramname">U</td><td>The output vector element type. Must be assignable from <span class="tt">T</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input vector of elements. </td></tr>
    <tr><td class="paramname">out</td><td>The output vector to insert into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e2b8e4e1c08763308012ae0ca7f72c3" name="a9e2b8e4e1c08763308012ae0ca7f72c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2b8e4e1c08763308012ae0ca7f72c3">&#9670;&#160;</a></span>keep_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Cond&gt; <br />
requires (std::is_invocable_r_v&lt;bool, Cond, typename Container::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::keep_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cond &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters elements of a container based on a predicate. </p>
<p>Returns a new container of the same type, containing only the elements for which the predicate returns <span class="tt">true</span>. This is similar to <span class="tt">std::copy_if</span> but uses insertion and returns a new container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="conceptndo_1_1_container.html" title="Concept that requires a type to fulfill typical container requirements.">Container</a></td><td>A container type with <span class="tt">value_type</span>, <span class="tt">cbegin/cend</span>, and <span class="tt">insert(end(), value)</span>. </td></tr>
    <tr><td class="paramname">Cond</td><td>A callable predicate type invocable with <span class="tt">Container::value_type</span> and returning <span class="tt">bool</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The input container. </td></tr>
    <tr><td class="paramname">c</td><td>The predicate to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container with elements that satisfy the predicate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function preserves the original order of elements. </dd>
<dd>
The function is <span class="tt">noexcept</span> if the predicate is <span class="tt">noexcept</span>. </dd></dl>

</div>
</div>
<a id="a03d7c5bc315b6dd3c4466d37ea95e643" name="a03d7c5bc315b6dd3c4466d37ea95e643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d7c5bc315b6dd3c4466d37ea95e643">&#9670;&#160;</a></span>map_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename F&gt; <br />
requires (std::is_invocable_v&lt;F, typename Container::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::map_from </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation to each element of a container and returns a container of the same type. </p>
<p>Each element is passed to the given function <span class="tt">f</span>, and the result is inserted into the resulting container. The input and output container must be the same type, which means the result of <span class="tt">f</span> must be convertible to <span class="tt">Container::value_type</span>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="conceptndo_1_1_container.html" title="Concept that requires a type to fulfill typical container requirements.">Container</a></td><td>A container type with <span class="tt">value_type</span>, <span class="tt">cbegin/cend</span>, and <span class="tt">insert(end(), value)</span>. </td></tr>
    <tr><td class="paramname">F</td><td>A callable that takes <span class="tt">Container::value_type</span> and returns a value convertible to <span class="tt">Container::value_type</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The input container. </td></tr>
    <tr><td class="paramname">f</td><td>The mapping function to apply to each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container containing the transformed elements.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The container must support <span class="tt">insert</span> at <span class="tt">end()</span>. </dd>
<dd>
The function is <span class="tt">noexcept</span> if the callable <span class="tt">f</span> is <span class="tt">noexcept</span>. </dd></dl>

</div>
</div>
<a id="a439e187de8bc525072d20b4461e8b599" name="a439e187de8bc525072d20b4461e8b599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439e187de8bc525072d20b4461e8b599">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Cond&gt; <br />
requires (std::is_invocable_r_v&lt;bool, Cond, typename Container::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::remove_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cond &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new container with elements that do <b>not</b> satisfy the given predicate. </p>
<p>This is the logical inverse of <span class="tt">keep_if</span>. Elements for which the predicate returns <span class="tt">true</span> are excluded from the result.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="conceptndo_1_1_container.html" title="Concept that requires a type to fulfill typical container requirements.">Container</a></td><td>A container type with <span class="tt">value_type</span>, <span class="tt">cbegin/cend</span>, and <span class="tt">insert(end(), value)</span>. </td></tr>
    <tr><td class="paramname">Cond</td><td>A callable predicate that returns <span class="tt">bool</span> when passed a <span class="tt">value_type</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The input container to be filtered. </td></tr>
    <tr><td class="paramname">c</td><td>The predicate to evaluate for each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container with only the elements that do <b>not</b> satisfy the predicate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The container type must support <span class="tt">insert</span> at <span class="tt">end()</span>. </dd>
<dd>
This function is <span class="tt">noexcept</span> if the predicate is <span class="tt">noexcept</span>. </dd></dl>

</div>
</div>
<a id="a0d05ac36588cc43e0659726e8e955f34" name="a0d05ac36588cc43e0659726e8e955f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d05ac36588cc43e0659726e8e955f34">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::reverse </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new container with the elements of the input container in reverse order. </p>
<p>Creates a new container of the same type, filled with the elements of <span class="tt">cont</span> in reverse order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="conceptndo_1_1_container.html" title="Concept that requires a type to fulfill typical container requirements.">Container</a></td><td>A container type supporting <span class="tt">crbegin</span>, <span class="tt">crend</span>, and <span class="tt">insert(end(), value)</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The input container to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new container with reversed elements.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes the container supports bidirectional iteration. </dd></dl>

</div>
</div>
<a id="a307cad0ca115c951c3c7bc46f65b39e2" name="a307cad0ca115c951c3c7bc46f65b39e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307cad0ca115c951c3c7bc46f65b39e2">&#9670;&#160;</a></span>spread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral N = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::spread </td>
          <td>(</td>
          <td class="paramtype">N</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector containing an inclusive range of integral values. </p>
<p>Returns a vector with all integers from <span class="tt">a</span> to <span class="tt">b</span> inclusive.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>An integral type (defaults to <span class="tt">int</span>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">b</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <span class="tt">std::vector&lt;N&gt;</span> containing the range <span class="tt">[a, b]</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">b &lt; a</span>, the returned vector will be empty. </dd></dl>

</div>
</div>
<a id="a97cbb65bb009f1c7a991fdf9fd272372" name="a97cbb65bb009f1c7a991fdf9fd272372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cbb65bb009f1c7a991fdf9fd272372">&#9670;&#160;</a></span>static_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ndo::static_for </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a callable <span class="tt">f</span> with compile-time indices from 0 to N-1. </p>
<p>This utility performs a compile-time "for loop" by expanding a parameter pack of indices into a call to <span class="tt">f.template operator()&lt;I...&gt;(args...)</span>.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">    <span class="keyword">template</span> &lt;std::size_t... I&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> x)<span class="keyword"> const </span>{</div>
<div class="line">        ((std::cout &lt;&lt; <span class="stringliteral">&quot;Index: &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot;, x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>), ...);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><a class="code hl_function" href="#a97cbb65bb009f1c7a991fdf9fd272372">ndo::static_for&lt;3&gt;</a>(Foo{}, 42);</div>
<div class="ttc" id="anamespacendo_html_a97cbb65bb009f1c7a991fdf9fd272372"><div class="ttname"><a href="#a97cbb65bb009f1c7a991fdf9fd272372">ndo::static_for</a></div><div class="ttdeci">constexpr void static_for(F &amp;&amp;f, Args &amp;&amp;... args)</div><div class="ttdoc">Executes a callable f with compile-time indices from 0 to N-1.</div><div class="ttdef"><b>Definition</b> static_for.hpp:31</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of iterations. </td></tr>
    <tr><td class="paramname">F</td><td>Callable type with a templated operator(). </td></tr>
    <tr><td class="paramname">Args</td><td>Types of additional arguments to forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable to invoke with the indices. </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments forwarded to the callable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dd07bd4accf005c34f55ad9bafc2101" name="a3dd07bd4accf005c34f55ad9bafc2101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd07bd4accf005c34f55ad9bafc2101">&#9670;&#160;</a></span>to_indexed_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::to_indexed_map </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <span class="tt">std::unordered_map</span> mapping indices to elements from a container. </p>
<p>Given a container, returns a map from <span class="tt">int</span> indices (starting at 0) to the container's elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="conceptndo_1_1_container.html" title="Concept that requires a type to fulfill typical container requirements.">Container</a></td><td>A container type with <span class="tt">value_type</span> and iterable with range-based for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The input container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <span class="tt">std::unordered_map&lt;int, Container::value_type&gt;</span> mapping indices to elements.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The container must be iterable and elements must be copyable/movable. </dd>
<dd>
The indices are <span class="tt">int</span> starting from 0. </dd></dl>

</div>
</div>
<a id="a6ea51ea050153fbe7f63e41df230aba1" name="a6ea51ea050153fbe7f63e41df230aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea51ea050153fbe7f63e41df230aba1">&#9670;&#160;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::unzip </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a tuple of pairs into a concatenated tuple of first and second elements. </p>
<p>Given a tuple like <span class="tt">std::tuple&lt;std::pair&lt;A, B&gt;, std::pair&lt;C, D&gt;, ...&gt;</span>, this function returns a tuple containing <span class="tt">(A, C, ..., B, D, ...)</span>.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t = std::make_tuple(std::pair{1, <span class="charliteral">&#39;a&#39;</span>}, std::pair{2, <span class="charliteral">&#39;b&#39;</span>});</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="#a6ea51ea050153fbe7f63e41df230aba1">unzip</a>(t); <span class="comment">// returns tuple&lt;int, int, char, char&gt; = (1, 2, &#39;a&#39;, &#39;b&#39;)</span></div>
<div class="ttc" id="anamespacendo_html_a6ea51ea050153fbe7f63e41df230aba1"><div class="ttname"><a href="#a6ea51ea050153fbe7f63e41df230aba1">ndo::unzip</a></div><div class="ttdeci">constexpr auto unzip(const T &amp;t) noexcept</div><div class="ttdoc">Splits a tuple of pairs into a concatenated tuple of first and second elements.</div><div class="ttdef"><b>Definition</b> unzip.hpp:31</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tuple type holding pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tuple of pairs to unzip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple concatenating all first elements followed by all second elements.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires C++20 for templated lambdas and <span class="tt">std::index_sequence</span>. </dd></dl>

</div>
</div>
<a id="acc8dfdc59a3ebf663e395c64c577a4ae" name="acc8dfdc59a3ebf663e395c64c577a4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8dfdc59a3ebf663e395c64c577a4ae">&#9670;&#160;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; <br />
requires (std::tuple_size_v&lt;T1&gt; == std::tuple_size_v&lt;T2&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ndo::zip </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines two tuples of the same size into a tuple of pairs. </p>
<p>Given two tuples <span class="tt">t1</span> and <span class="tt">t2</span>, returns a tuple where each element is a <span class="tt">std::pair</span> formed by the corresponding elements of <span class="tt">t1</span> and <span class="tt">t2</span>.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"><span class="keyword">auto</span> t2 = std::make_tuple(2.0, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="#acc8dfdc59a3ebf663e395c64c577a4ae">zip</a>(t1, t2); <span class="comment">// std::tuple&lt;std::pair&lt;int, double&gt;, std::pair&lt;char, const char*&gt;&gt;</span></div>
<div class="ttc" id="anamespacendo_html_acc8dfdc59a3ebf663e395c64c577a4ae"><div class="ttname"><a href="#acc8dfdc59a3ebf663e395c64c577a4ae">ndo::zip</a></div><div class="ttdeci">constexpr auto zip(const T1 &amp;t1, const T2 &amp;t2) noexcept</div><div class="ttdoc">Combines two tuples of the same size into a tuple of pairs.</div><div class="ttdef"><b>Definition</b> zip.hpp:35</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first tuple. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>The first input tuple. </td></tr>
    <tr><td class="paramname">t2</td><td>The second input tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of pairs combining elements from <span class="tt">t1</span> and <span class="tt">t2</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires <span class="tt">std::tuple_size_v&lt;T1&gt; == std::tuple_size_v&lt;T2&gt;</span>. </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a3d8877e34a484a7b879102872d175b01" name="a3d8877e34a484a7b879102872d175b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8877e34a484a7b879102872d175b01">&#9670;&#160;</a></span>ndo_nothing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structndo_1_1ndo__null__t.html">ndo_null_t</a> ndo::ndo_nothing {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Singleton instance of <span class="tt"><a class="el" href="structndo_1_1ndo__null__t.html" title="Tag type used to represent &quot;no value&quot;.">ndo_null_t</a></span>. </p>
<p>Used as the default "empty" value in <span class="tt">maybe</span> or <span class="tt">either</span>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacendo.html">ndo</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
